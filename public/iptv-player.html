<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XPENG IPTV Player - Web App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #f1f5f9;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #06b6d4, #3b82f6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .setup-form, .player-section {
            background: rgba(255, 255, 255, 0.08);
            padding: 30px;
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #cbd5e1;
        }
        
        input, select {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #f1f5f9;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #06b6d4;
            background: rgba(255, 255, 255, 0.15);
        }
        
        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #06b6d4, #3b82f6);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(6, 182, 212, 0.4);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            margin-left: 10px;
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .channels-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .channel-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .channel-card:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
            border-color: #06b6d4;
        }
        
        .channel-card h3 {
            font-size: 16px;
            margin-bottom: 5px;
            color: #f1f5f9;
        }
        
        .channel-card p {
            font-size: 12px;
            color: #94a3b8;
        }
        
        .video-player {
            margin-top: 20px;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
        }
        
        video {
            width: 100%;
            max-height: 600px;
        }
        
        .hidden {
            display: none;
        }
        
        .status-message {
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .status-success {
            background: rgba(34, 197, 94, 0.2);
            border: 1px solid rgba(34, 197, 94, 0.5);
            color: #86efac;
        }
        
        .status-error {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            color: #fca5a5;
        }
        
        .search-box {
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #f1f5f9;
            font-size: 14px;
        }
        
        .current-playing {
            background: rgba(6, 182, 212, 0.2);
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid #06b6d4;
        }
        
        .debug-logs {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .debug-log-entry {
            margin-bottom: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.2);
        }
        
        .log-info { color: #06b6d4; }
        .log-success { color: #22c55e; }
        .log-warning { color: #f59e0b; }
        .log-error { color: #ef4444; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé¨ XPENG IPTV Player</h1>
            <p>Web App avec sauvegarde automatique</p>
        </div>
        
        <div id="setupSection" class="setup-form">
            <h2 style="margin-bottom: 20px;">üì° Configuration IPTV</h2>
            
            <div class="form-group">
                <label for="connectionType">Type de connexion :</label>
                <select id="connectionType" onchange="updateFormFields()">
                    <option value="m3u">URL M3U/M3U8</option>
                    <option value="xtream">Xtream Codes API</option>
                </select>
            </div>
            
            <div id="m3uFields">
                <div class="form-group">
                    <label for="m3uUrl">URL de la playlist M3U :</label>
                    <input type="url" id="m3uUrl" placeholder="https://example.com/playlist.m3u8">
                </div>
            </div>
            
            <div id="xtreamFields" class="hidden">
                <div class="form-group">
                    <label for="xtreamUrl">URL du serveur :</label>
                    <input type="url" id="xtreamUrl" placeholder="http://server.com:port">
                </div>
                <div class="form-group">
                    <label for="xtreamUsername">Nom d'utilisateur :</label>
                    <input type="text" id="xtreamUsername" placeholder="username">
                </div>
                <div class="form-group">
                    <label for="xtreamPassword">Mot de passe :</label>
                    <input type="password" id="xtreamPassword" placeholder="password">
                </div>
            </div>
            
            <button onclick="saveAndConnect()">üíæ Sauvegarder et Charger</button>
            <button class="btn-secondary" onclick="clearStorage()">üóëÔ∏è Effacer les donn√©es</button>
        </div>
        
        <div id="playerSection" class="player-section hidden">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2>üì∫ Cha√Ænes disponibles</h2>
                <button class="btn-secondary" onclick="showSetup()">‚öôÔ∏è Configuration</button>
            </div>
            
            <input type="text" id="searchBox" class="search-box" placeholder="üîç Rechercher une cha√Æne..." onkeyup="filterChannels()">
            
            <div id="statusMessage"></div>
            
            <!-- Zone de debug verbose -->
            <div id="debugLogs" class="debug-logs hidden">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <strong>üîç Logs de Debug</strong>
                    <button onclick="clearDebugLogs()" style="padding: 4px 8px; font-size: 12px;">üóëÔ∏è Effacer</button>
                </div>
                <div id="debugContent" style="font-family: monospace; font-size: 11px; max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px;"></div>
            </div>
            
            <div id="currentPlaying" class="current-playing hidden">
                <strong>‚ñ∂Ô∏è En cours :</strong> <span id="playingName">-</span>
            </div>
            
            <div id="videoContainer" class="video-player hidden">
                <video id="videoPlayer" controls autoplay></video>
            </div>
            
            <div id="channelsList" class="channels-grid"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        let channels = [];
        let hls = null;
        
        // Charger la configuration sauvegard√©e au d√©marrage
        window.onload = function() {
            loadSavedConfig();
        };
        
        // Fonction pour logger de mani√®re verbose
        function debugLog(message, type = 'info') {
            const debugContent = document.getElementById('debugContent');
            const debugLogs = document.getElementById('debugLogs');
            const timestamp = new Date().toLocaleTimeString('fr-FR');
            
            const entry = document.createElement('div');
            entry.className = `debug-log-entry log-${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            
            debugContent.appendChild(entry);
            debugLogs.classList.remove('hidden');
            
            // Auto-scroll vers le bas
            debugContent.scrollTop = debugContent.scrollHeight;
            
            // Aussi logger dans console
            console.log(`[${type.toUpperCase()}]`, message);
        }
        
        function clearDebugLogs() {
            document.getElementById('debugContent').innerHTML = '';
            document.getElementById('debugLogs').classList.add('hidden');
        }
        
        function updateFormFields() {
            const type = document.getElementById('connectionType').value;
            document.getElementById('m3uFields').classList.toggle('hidden', type !== 'm3u');
            document.getElementById('xtreamFields').classList.toggle('hidden', type !== 'xtream');
        }
        
        function saveAndConnect() {
            clearDebugLogs();
            debugLog('üöÄ D√©marrage de la connexion...', 'info');
            
            const type = document.getElementById('connectionType').value;
            debugLog(`üì¶ Type de connexion: ${type === 'm3u' ? 'M3U/M3U8' : 'Xtream Codes'}`, 'info');
            
            let config = { type };
            
            if (type === 'm3u') {
                config.url = document.getElementById('m3uUrl').value.trim();
                debugLog('‚öôÔ∏è Validation des donn√©es M3U...', 'info');
                
                if (!config.url) {
                    debugLog('‚ùå ERREUR: URL M3U vide', 'error');
                    showStatus('‚ùå Veuillez entrer une URL M3U', 'error');
                    return;
                }
                
                if (!config.url.startsWith('http://') && !config.url.startsWith('https://')) {
                    debugLog('‚ö†Ô∏è ATTENTION: L\'URL ne commence pas par http:// ou https://', 'warning');
                    debugLog(`URL fournie: ${config.url}`, 'warning');
                }
                
                if (!config.url.includes('.m3u') && !config.url.includes('.m3u8')) {
                    debugLog('‚ö†Ô∏è ATTENTION: L\'URL ne semble pas √™tre un fichier M3U/M3U8', 'warning');
                }
                
                debugLog(`‚úÖ URL M3U valide: ${config.url}`, 'success');
                
            } else {
                config.url = document.getElementById('xtreamUrl').value.trim();
                config.username = document.getElementById('xtreamUsername').value.trim();
                config.password = document.getElementById('xtreamPassword').value.trim();
                
                debugLog('‚öôÔ∏è Validation des donn√©es Xtream...', 'info');
                
                const missing = [];
                if (!config.url) missing.push('URL serveur');
                if (!config.username) missing.push('Nom d\'utilisateur');
                if (!config.password) missing.push('Mot de passe');
                
                if (missing.length > 0) {
                    debugLog(`‚ùå ERREUR: Champs manquants: ${missing.join(', ')}`, 'error');
                    showStatus(`‚ùå Veuillez remplir: ${missing.join(', ')}`, 'error');
                    return;
                }
                
                if (!config.url.startsWith('http://') && !config.url.startsWith('https://')) {
                    debugLog('‚ùå ERREUR: L\'URL serveur doit commencer par http:// ou https://', 'error');
                    debugLog(`URL fournie: ${config.url}`, 'error');
                    showStatus('‚ùå URL serveur invalide (doit commencer par http:// ou https://)', 'error');
                    return;
                }
                
                if (config.url.endsWith('/')) {
                    debugLog('‚ö†Ô∏è URL se termine par /, sera nettoy√© automatiquement', 'warning');
                }
                
                debugLog(`‚úÖ URL serveur: ${config.url}`, 'success');
                debugLog(`‚úÖ Username: ${config.username}`, 'success');
                debugLog(`‚úÖ Password: ${'*'.repeat(config.password.length)} (${config.password.length} caract√®res)`, 'success');
                
                const specialChars = /[^a-zA-Z0-9_-]/;
                if (specialChars.test(config.username)) {
                    debugLog('‚ö†Ô∏è Username contient des caract√®res sp√©ciaux, sera encod√©', 'warning');
                }
                if (specialChars.test(config.password)) {
                    debugLog('‚ö†Ô∏è Password contient des caract√®res sp√©ciaux, sera encod√©', 'warning');
                }
            }
            
            try {
                localStorage.setItem('iptvConfig', JSON.stringify(config));
                debugLog('üíæ Configuration sauvegard√©e dans localStorage', 'success');
                showStatus('‚úÖ Configuration sauvegard√©e !', 'success');
            } catch (e) {
                debugLog(`‚ùå ERREUR localStorage: ${e.message}`, 'error');
                showStatus('‚ö†Ô∏è Configuration non sauvegard√©e (localStorage plein?)', 'warning');
            }
            
            debugLog('üöÄ Lancement du chargement des cha√Ænes...', 'info');
            loadChannels(config);
        }
        
        function loadSavedConfig() {
            const saved = localStorage.getItem('iptvConfig');
            if (saved) {
                const config = JSON.parse(saved);
                document.getElementById('connectionType').value = config.type;
                updateFormFields();
                
                if (config.type === 'm3u') {
                    document.getElementById('m3uUrl').value = config.url;
                } else {
                    document.getElementById('xtreamUrl').value = config.url;
                    document.getElementById('xtreamUsername').value = config.username;
                    document.getElementById('xtreamPassword').value = config.password;
                }
                
                // Auto-charger les cha√Ænes
                showStatus('üîÑ Chargement de la configuration sauvegard√©e...', 'success');
                setTimeout(() => loadChannels(config), 500);
            }
        }
        
        async function loadChannels(config) {
            try {
                if (config.type === 'm3u') {
                    await loadM3U(config.url);
                } else {
                    await loadXtream(config);
                }
            } catch (error) {
                showStatus('‚ùå Erreur: ' + error.message, 'error');
            }
        }
        
        async function loadM3U(url) {
            showStatus('üîÑ Chargement de la playlist M3U...', 'success');
            
            // Utiliser CORS proxy si n√©cessaire
            const proxyUrl = 'https://cors-anywhere.herokuapp.com/';
            const fetchUrl = url.startsWith('http://') ? proxyUrl + url : url;
            
            try {
                const response = await fetch(fetchUrl);
                const text = await response.text();
                
                channels = parseM3U(text);
                displayChannels();
                showPlayer();
                showStatus(`‚úÖ ${channels.length} cha√Ænes charg√©es !`, 'success');
            } catch (error) {
                // Si CORS proxy √©choue, essayer direct
                try {
                    const response = await fetch(url);
                    const text = await response.text();
                    channels = parseM3U(text);
                    displayChannels();
                    showPlayer();
                    showStatus(`‚úÖ ${channels.length} cha√Ænes charg√©es !`, 'success');
                } catch (err) {
                    showStatus('‚ùå Impossible de charger la playlist. V√©rifiez l\'URL.', 'error');
                }
            }
        }
        
        function parseM3U(text) {
            const lines = text.split('\n');
            const parsed = [];
            let current = {};
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line.startsWith('#EXTINF:')) {
                    const match = line.match(/,(.+)$/);
                    current.name = match ? match[1].trim() : 'Cha√Æne ' + (parsed.length + 1);
                } else if (line && !line.startsWith('#')) {
                    current.url = line;
                    if (current.name) {
                        parsed.push({...current});
                    }
                    current = {};
                }
            }
            
            return parsed;
        }
        
        async function loadXtream(config) {
            debugLog('üíâ loadXtream() appel√©', 'info');
            showStatus('üîÑ Connexion au serveur Xtream Codes...', 'success');
            
            let serverUrl = config.url.trim();
            debugLog(`üßπ URL originale: ${serverUrl}`, 'info');
            
            if (serverUrl.endsWith('/')) {
                serverUrl = serverUrl.slice(0, -1);
                debugLog(`üßπ URL nettoy√©e (/ retir√©): ${serverUrl}`, 'info');
            }
            
            const apiUrl = `${serverUrl}/player_api.php?username=${encodeURIComponent(config.username)}&password=${encodeURIComponent(config.password)}&action=get_live_streams`;
            const safeApiUrl = apiUrl.replace(config.password, '***').replace(encodeURIComponent(config.password), '***');
            
            debugLog(`üîó URL API construite: ${safeApiUrl}`, 'info');
            
            const startTime = Date.now();
            
            try {
                debugLog('üîÑ √âTAPE 1/3: Tentative de connexion directe au serveur...', 'info');
                showStatus('üîÑ √âtape 1/3: Connexion au serveur...', 'success');
                
                let response;
                let data;
                let usedProxy = false;
                
                try {
                    debugLog(`üéØ Envoi requ√™te GET vers le serveur...`, 'info');
                    
                    response = await fetch(apiUrl, {
                        method: 'GET',
                        headers: { 'Accept': 'application/json' }
                    });
                    
                    const elapsed = Date.now() - startTime;
                    debugLog(`‚è±Ô∏è R√©ponse re√ßue en ${elapsed}ms`, 'info');
                    debugLog(`üìä Status HTTP: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
                    debugLog(`üì¶ Content-Type: ${response.headers.get('content-type')}`, 'info');
                    
                    if (!response.ok) {
                        debugLog(`‚ùå Erreur HTTP ${response.status}`, 'error');
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const text = await response.text();
                    debugLog(`üìù Longueur r√©ponse: ${text.length} caract√®res`, 'info');
                    debugLog(`üì• Aper√ßu r√©ponse: ${text.substring(0, 200)}${text.length > 200 ? '...' : ''}`, 'info');
                    
                    try {
                        data = JSON.parse(text);
                        debugLog(`‚úÖ JSON pars√© avec succ√®s`, 'success');
                    } catch (e) {
                        debugLog(`‚ùå ERREUR parsing JSON: ${e.message}`, 'error');
                        throw new Error('La r√©ponse n\'est pas du JSON valide: ' + text.substring(0, 100));
                    }
                    
                } catch (directError) {
                    debugLog(`‚ö†Ô∏è Connexion directe √©chou√©e: ${directError.message}`, 'warning');
                    debugLog(`üîÑ √âTAPE 2/3: Tentative avec proxy CORS...`, 'info');
                    showStatus('üîÑ √âtape 2/3: Utilisation du proxy CORS...', 'success');
                    
                    const proxyUrl = 'https://api.allorigins.win/raw?url=';
                    const proxiedUrl = proxyUrl + encodeURIComponent(apiUrl);
                    debugLog(`üåê Proxy utilis√©: api.allorigins.win`, 'info');
                    
                    try {
                        response = await fetch(proxiedUrl);
                        const elapsed = Date.now() - startTime;
                        debugLog(`‚è±Ô∏è R√©ponse proxy re√ßue en ${elapsed}ms`, 'info');
                        
                        const text = await response.text();
                        debugLog(`üìù Longueur r√©ponse proxy: ${text.length} caract√®res`, 'info');
                        
                        data = JSON.parse(text);
                        usedProxy = true;
                        debugLog(`‚úÖ Connexion via proxy r√©ussie`, 'success');
                    } catch (proxyError) {
                        debugLog(`‚ùå ERREUR proxy: ${proxyError.message}`, 'error');
                        throw new Error(`Proxy aussi √©chou√©: ${proxyError.message}`);
                    }
                }
                
                debugLog(`üîÑ √âTAPE 3/3: Analyse et traitement des donn√©es...`, 'info');
                showStatus('üîÑ √âtape 3/3: Traitement des cha√Ænes...', 'success');
                
                debugLog(`üîç Type de donn√©es re√ßues: ${Array.isArray(data) ? 'Array' : typeof data}`, 'info');
                
                let streamsList = [];
                
                if (Array.isArray(data)) {
                    streamsList = data;
                    debugLog(`‚úÖ Format d√©tect√©: Array direct de ${streamsList.length} √©l√©ments`, 'success');
                } else if (data && typeof data === 'object') {
                    debugLog(`üîç Cl√©s de l'objet: ${Object.keys(data).join(', ')}`, 'info');
                    
                    if (data.streams && Array.isArray(data.streams)) {
                        streamsList = data.streams;
                        debugLog(`‚úÖ Format d√©tect√©: data.streams avec ${streamsList.length} cha√Ænes`, 'success');
                    } else if (data.data && Array.isArray(data.data)) {
                        streamsList = data.data;
                        debugLog(`‚úÖ Format d√©tect√©: data.data avec ${streamsList.length} cha√Ænes`, 'success');
                    } else {
                        if (data.user_info) {
                            debugLog(`üë§ Info utilisateur pr√©sente:`, 'info');
                            debugLog(`   - Username: ${data.user_info.username || 'N/A'}`, 'info');
                            debugLog(`   - Status: ${data.user_info.status || 'N/A'}`, 'info');
                            debugLog(`   - Exp date: ${data.user_info.exp_date || 'N/A'}`, 'info');
                            debugLog(`‚ùå Aucune cha√Æne disponible pour cet abonnement`, 'error');
                            throw new Error('Aucune cha√Æne disponible pour cet abonnement');
                        }
                        debugLog(`‚ùå Format de r√©ponse non reconnu`, 'error');
                        throw new Error('Format de r√©ponse inattendu: ' + JSON.stringify(data).substring(0, 100));
                    }
                } else {
                    debugLog(`‚ùå Type de donn√©es invalide: ${typeof data}`, 'error');
                    throw new Error('Donn√©es invalides re√ßues du serveur');
                }
                
                if (streamsList.length === 0) {
                    debugLog(`‚ùå Liste de cha√Ænes vide`, 'error');
                    throw new Error('Aucune cha√Æne trouv√©e sur ce serveur');
                }
                
                debugLog(`‚úÖ ${streamsList.length} cha√Ænes trouv√©es dans la r√©ponse`, 'success');
                
                if (streamsList.length > 0) {
                    const first = streamsList[0];
                    debugLog(`üì¶ Exemple 1√®re cha√Æne:`, 'info');
                    debugLog(`   - stream_id: ${first.stream_id || first.id || 'N/A'}`, 'info');
                    debugLog(`   - name: ${first.name || first.stream_display_name || 'N/A'}`, 'info');
                    debugLog(`   - category: ${first.category_name || first.category || 'N/A'}`, 'info');
                }
                
                debugLog(`üõ†Ô∏è Mapping des cha√Ænes...`, 'info');
                
                channels = streamsList.map((ch, index) => {
                    const streamId = ch.stream_id || ch.id || ch.num;
                    const channelName = ch.name || ch.stream_display_name || ch.title || `Cha√Æne ${streamId}`;
                    const categoryName = ch.category_name || ch.category || '';
                    
                    if (index < 3) {
                        debugLog(`   [${index + 1}] ${channelName} (ID: ${streamId})`, 'info');
                    }
                    
                    return {
                        name: channelName,
                        url: `${serverUrl}/live/${config.username}/${config.password}/${streamId}.m3u8`,
                        category: categoryName,
                        streamId: streamId
                    };
                });
                
                if (streamsList.length > 3) {
                    debugLog(`   ... et ${streamsList.length - 3} autres cha√Ænes`, 'info');
                }
                
                const totalTime = Date.now() - startTime;
                debugLog(`‚è±Ô∏è Temps total de traitement: ${totalTime}ms`, 'success');
                debugLog(`‚úÖ ${channels.length} cha√Ænes mapp√©es avec succ√®s`, 'success');
                
                displayChannels();
                showPlayer();
                
                const successMsg = `‚úÖ ${channels.length} cha√Ænes Xtream charg√©es ${usedProxy ? '(via proxy)' : '(direct)'} !`;
                showStatus(successMsg, 'success');
                debugLog(successMsg, 'success');
                
            } catch (error) {
                const totalTime = Date.now() - startTime;
                debugLog(`‚ùå ERREUR FATALE apr√®s ${totalTime}ms`, 'error');
                debugLog(`‚ùå Type d'erreur: ${error.name}`, 'error');
                debugLog(`‚ùå Message: ${error.message}`, 'error');
                
                if (error.stack) {
                    debugLog(`üîç Stack trace:`, 'error');
                    error.stack.split('\n').slice(0, 3).forEach(line => {
                        debugLog(`   ${line.trim()}`, 'error');
                    });
                }
                
                let errorMessage = '‚ùå Erreur Xtream: ';
                let userTip = '';
                
                if (error.message.includes('Failed to fetch')) {
                    errorMessage += 'Impossible de contacter le serveur.';
                    userTip = 'üí° V√©rifiez: 1) L\'URL du serveur, 2) Votre connexion Internet, 3) Le serveur est en ligne';
                    debugLog(userTip, 'warning');
                } else if (error.message.includes('HTTP 401') || error.message.includes('Unauthorized')) {
                    errorMessage += 'Identifiants incorrects.';
                    userTip = 'üí° V√©rifiez: 1) Nom d\'utilisateur correct, 2) Mot de passe correct, 3) Pas d\'espaces en trop';
                    debugLog(userTip, 'warning');
                } else if (error.message.includes('HTTP 403') || error.message.includes('Forbidden')) {
                    errorMessage += 'Acc√®s refus√©.';
                    userTip = 'üí° V√©rifiez: 1) Abonnement valide, 2) Pas expir√©, 3) Connexions simultan√©es limit√©es';
                    debugLog(userTip, 'warning');
                } else if (error.message.includes('HTTP 404')) {
                    errorMessage += 'Serveur introuvable.';
                    userTip = 'üí° V√©rifiez: 1) URL compl√®te avec port, 2) Pas de faute de frappe, 3) Serveur utilise bien Xtream API';
                    debugLog(userTip, 'warning');
                } else if (error.message.includes('JSON')) {
                    errorMessage += 'R√©ponse invalide du serveur.';
                    userTip = 'üí° Le serveur ne semble pas √™tre un serveur Xtream Codes valide';
                    debugLog(userTip, 'warning');
                } else if (error.message.includes('Aucune cha√Æne')) {
                    errorMessage += error.message;
                    userTip = 'üí° Votre abonnement ne contient aucune cha√Æne live';
                    debugLog(userTip, 'warning');
                } else {
                    errorMessage += error.message;
                }
                
                showStatus(errorMessage, 'error');
                debugLog(`üíî √âchec total du chargement Xtream`, 'error');
            }
        }
        
        function displayChannels() {
            const container = document.getElementById('channelsList');
            container.innerHTML = '';
            
            channels.forEach((channel, index) => {
                const card = document.createElement('div');
                card.className = 'channel-card';
                card.onclick = () => playChannel(channel);
                
                card.innerHTML = `
                    <h3>üì∫ ${channel.name}</h3>
                    ${channel.category ? `<p>${channel.category}</p>` : ''}
                `;
                
                container.appendChild(card);
            });
        }
        
        function filterChannels() {
            const search = document.getElementById('searchBox').value.toLowerCase();
            const cards = document.querySelectorAll('.channel-card');
            
            cards.forEach(card => {
                const text = card.textContent.toLowerCase();
                card.style.display = text.includes(search) ? 'block' : 'none';
            });
        }
        
        function playChannel(channel) {
            const video = document.getElementById('videoPlayer');
            const container = document.getElementById('videoContainer');
            const playing = document.getElementById('currentPlaying');
            const playingName = document.getElementById('playingName');
            
            container.classList.remove('hidden');
            playing.classList.remove('hidden');
            playingName.textContent = channel.name;
            
            // Arr√™ter HLS pr√©c√©dent
            if (hls) {
                hls.destroy();
            }
            
            // D√©tecter si c'est HLS
            if (channel.url.includes('.m3u8')) {
                if (Hls.isSupported()) {
                    hls = new Hls();
                    hls.loadSource(channel.url);
                    hls.attachMedia(video);
                } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                    video.src = channel.url;
                }
            } else {
                video.src = channel.url;
            }
            
            video.play();
            
            // Scroll vers le player
            container.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        function showPlayer() {
            document.getElementById('setupSection').classList.add('hidden');
            document.getElementById('playerSection').classList.remove('hidden');
        }
        
        function showSetup() {
            document.getElementById('setupSection').classList.remove('hidden');
            document.getElementById('playerSection').classList.add('hidden');
        }
        
        function showStatus(message, type) {
            const status = document.getElementById('statusMessage');
            status.textContent = message;
            status.className = 'status-message status-' + type;
            status.style.display = 'block';
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 5000);
        }
        
        function clearStorage() {
            if (confirm('Voulez-vous vraiment effacer toutes les donn√©es sauvegard√©es ?')) {
                localStorage.removeItem('iptvConfig');
                location.reload();
            }
        }
    </script>
</body>
</html>
